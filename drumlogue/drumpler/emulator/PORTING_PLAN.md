# JV-880 Emulator Port to Drumlogue - Implementation Plan

## Overview

Porting the JV-880 emulator (based on NukeYKT's Nuked-SC55) to run as a drumlogue synth unit with embedded ROMs.

## Architecture

### Original JV-880 JUCE Structure
```
PluginProcessor (JUCE)
└── MCU (main emulator)
    ├── PCM (sound chip - DSP core)
    ├── SubMCU (sub-microcontroller)
    ├── LCD (display - not needed)
    ├── MCU_Timer (timing)
    └── ROM files (loaded from disk)
```

### Target Drumlogue Structure
```
Synth class (drumlogue unit)
└── JV880Emulator wrapper
    └── MCU (adapted emulator)
        ├── PCM (sound chip)
        ├── SubMCU (if needed)
        ├── MCU_Timer
        └── ROM arrays (embedded in binary)
```

## Key Technical Challenges

### 1. ROM Embedding
- **Original**: Loads ROMs from files at runtime
- **Target**: Embed ROMs as `const unsigned char[]` arrays in source
- **Solution**: Use `build_rom_unit.sh` to generate `rom_data.cc` with embedded ROMs

### 2. Sample Rate Conversion
- **Original**: Emulator runs at 64kHz internally, resamples to plugin rate using libsamplerate
- **Target**: Drumlogue runs at 48kHz natively
- **Solution**: 
  - Keep internal 64kHz rate for accuracy
  - Implement simple linear interpolation for 64kHz→48kHz (ratio 4:3)
  - Or: Modify emulator to run at 48kHz directly (may affect accuracy)

### 3. Audio Buffer Interface  
- **Original**: `MCU_PostSample(int *sample)` - posts stereo int32 samples to buffer
- **Target**: `unit_render(const float *in, float *out, uint32_t frames)` - processes float buffers
- **Solution**: Accumulate emulator samples, convert int32→float, handle buffer size mismatches

### 4. Memory Constraints
- **Binary size**: ~20MB with ROM embedded (under 32MB limit ✓)
- **Runtime RAM**: Need to measure, but emulator state is relatively small (~few hundred KB)
- **Stack**: Avoid deep recursion (emulator is mostly iterative ✓)

### 5. Dependencies to Remove
- **JUCE framework**: All JUCE includes and types
- **libsamplerate**: Resampling library
- **FILE I/O**: `fopen`, `fread`, ROM file loading
- **std::vector** in hot paths: Pre-allocate fixed-size arrays
- **LCD/UI code**: Stub out or remove entirely

### 6. Timing & Clocking
- **Original**: Uses `std::chrono` and precise cycle counting
- **Target**: Drive emulator based on audio callback rate
- **Solution**: Calculate cycles per audio frame, call `MCU_Update(cycles)`

## Implementation Steps

### Phase 1: Stub & Adapt Headers ✓
1. Remove JUCE includes
2. Replace `std::vector` with fixed arrays where hot-path
3. Stub out LCD functions
4. Add drumlogue-compatible types

### Phase 2: Embed ROMs
1. Modify MCU to accept embedded ROM pointers instead of file paths
2. Remove all `fopen`/`fread`/file I/O code
3. Link `rom_data.cc` generated by `build_rom_unit.sh`

### Phase 3: Audio Path Integration
1. Create `JV880Emulator` wrapper class
2. Implement buffer accumulation and conversion
3. Handle 64kHz→48kHz resampling
4. Integrate with `Synth::Render()`

### Phase 4: MIDI & Parameters
1. Map drumlogue MIDI callbacks to emulator MIDI queue
2. Design parameter layout (part select, volume, effects, etc.)
3. Implement `unit_set_param_value()` to control emulator
4. Add preset selection (Program Change)
5. Optional: Parse preset names from ROM

### Phase 5: Testing & Optimization
1. Build test unit with embedded ROM
2. Validate audio output quality
3. Measure CPU usage (target <80%)
4. Optimize hot paths if needed

## File Modifications

### Files to Keep (Adapt)
- `pcm.cpp/h` - Core DSP, minimal changes
- `mcu.cpp/h` - Main MCU, remove file I/O, adapt ROM loading
- `mcu_interrupt.cpp/h` - Keep as-is
- `mcu_opcodes.h` - Keep as-is  
- `mcu_timer.cpp/h` - Keep, may need timing adjustments
- `submcu.cpp/h` - Keep (needed for JV-880 mode)

### Files to Stub/Minimize
- `lcd.cpp/h` - Stub out (no display on drumlogue)

### Files to Add
- `jv880_wrapper.h/cpp` - Drumlogue wrapper for emulator
- `rom_data.cc` - Generated ROM arrays (via `build_rom_unit.sh`)
- Updated `synth.h` - Integrate JV880Emulator
- Updated `unit.cc` - Wire MIDI/parameters to emulator

## Parameter Design (24 params max)

### Page 1: Voice & Part
- PART (1-16) - Select active part (MIDI channel)
- POLY (1-32) - Polyphony limit (reserved)
- LEVEL (0-100%) - Part volume (CC7)
- PAN (L63-R63) - Part pan (CC10)

### Page 2: Tone Control
- TONE (0-127) - Tone/patch select (Program Change)
- CUTOFF (0-100%) - Filter cutoff (CC74)
- RESONANCE (0-100%) - Filter resonance (CC71)
- ATTACK (0-100%) - Attack time (CC73)

### Page 3: Effects
- REVERB (0-100%) - Reverb send (CC91)
- CHORUS (0-100%) - Chorus send (CC93)
- DELAY (0-100%) - Delay send (CC94)
- (blank)

### Page 4-6: Reserved for expansion

## Memory Budget Estimate

### Binary Size
- Emulator code: ~500KB
- Base ROMs (rom1+rom2+waverom1+waverom2): ~4.3MB
- Expansion ROM (one SR-JV80): ~8MB
- **Total per unit**: ~13MB (well under 32MB limit)

### Runtime RAM
- Emulator state (RAM, registers, buffers): ~512KB
- Audio conversion buffers: ~64KB
- **Total**: ~600KB (should be acceptable)

## Known Risks

1. **CPU performance**: Cycle-accurate emulation may be too heavy
   - Mitigation: Profile early, optimize hot loops, consider accuracy trade-offs
   
2. **Timing precision**: Drumlogue callback rate vs emulator cycle rate mismatch
   - Mitigation: Careful cycle calculation, test with various buffer sizes

3. **Licensing**: Non-commercial restriction
   - Accept: This is for personal/research use only

4. **Audio quality**: Resampling artifacts, emulation accuracy
   - Mitigation: Test thoroughly, consider alternative resampling methods

## Next Steps

1. Create `jv880_wrapper.h/cpp` skeleton
2. Adapt MCU to accept embedded ROM pointers
3. Stub out LCD functions
4. Build first test unit (silent, just to verify linking)
5. Implement audio path step-by-step
6. Add MIDI and parameter control

## Success Criteria

- [ ] Unit builds without errors
- [ ] Audio output is clean (no pops/clicks)
- [ ] Sounds identical to original JV-880 (within reasonable tolerance)
- [ ] CPU usage <80% at 48kHz
- [ ] MIDI note on/off works correctly
- [x] Parameters control emulator via MIDI CC/Program Change
- [ ] Preset names parsed from ROM (optional enhancement)
- [ ] Multiple ROMs can be built as separate units

## References

- Original emulator: https://github.com/giulioz/jv880_juce
- Nuked-SC55 (base): https://github.com/nukeykt/Nuked-SC55
- JV-880 service manual: [if available]
- Drumlogue SDK docs: logue-sdk/platform/drumlogue/
